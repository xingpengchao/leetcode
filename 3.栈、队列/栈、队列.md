## 一、双栈模拟队列

## 思路：栈 1 用作入队，栈 2 用作出队，当栈 2 为空时，将栈 1 全部压栈到栈 2，栈 2 在出栈(即出队列)

## 代码

```
 let stack1 = [],stack2 = [];
 function push(node){
 stack1.push(node);
 }
 function pop(){
 if(stack2.length === 0){
  if(stack1.length === 0){
   return null;
  }else{
   let len = stack1.length;
   for(let i=0; i<len; i++){
    stack2.push(stack1.pop());
   }
   return stack2.pop();
  }
 }else{
  return stack2.pop();
 }
 }
```

## 二、有效的括号 (富途手撕代码)

## 思路：只处理左半边括号

## 代码

```
const isValid = function(s){
 let stack = [];
 for(let i=0; i<s.length; i++){
  if(s[i] === '('){
   stack.push(')');
  }else if(s[i] === '['){
   stack.push(']');
  }else if(s[i] === '{'){
   stack.push('}');
  }else if(stack.pop() !== s[i]){
   return false;
  }
 }
 return !stack.length;
}
```

## 三、将无序栈转为有序栈 (华为手撕代码) (要求时间复杂度 O(1))

## 思路：只有递归空间复杂度才是 O(1)

## 代码

```js
function sort(stack) {
  const _sort = () => {
    if (stack.length <= 1) return stack;
    let num = stack.pop();
    if (num < stack[stack.length - 1]) {
      let temp = stack.pop();
      stack.push(num);
      num = temp;
      _sort(stack);
    } else {
      _sort(stack);
    }
    stack.push(num);
  };
  let index = stack.length;
  while (index > 0) {
    _sort(); //每一次排序完栈底元素最小
    index--;
  }
  return stack;
}
```
