## 一、前序遍历(非递归版)

## 思路

> 需要一个栈来辅助，把遍历结果 push 进数组中作为返回结果。
>
> 1. 将根节点放进栈中
> 2. 如果栈不为空，出栈一个节点 push 进数组中;如果该节点右子树不为空，把右子树放进栈中;
>    如果该节点左子树不为空，把左子树放进栈中
> 3. 重复步骤二，直到栈为空，返回数组

## 代码

```js
function preOrderTraversal(root) {
  let res = [];
  let stack = [];
  if (root == null) {
    return res;
  }
  stack.push(root);
  while (stack.length) {
    let node = stack.pop();
    res.push(node.val);
    if (node.right) {
      stack.push(node.right);
    }
    if (node.left) {
      stack.push(node.right);
    }
  }
  return res;
}
```

## 二、中序遍历(非递归版)

## 代码

```js
function inOrderTraversal(root) {
  let res = [];
  let stack = [];
  while (root != null || stack.length) {
    if (root) {
      stack.push(root);
      root = root.left;
    } else {
      let node = stack.pop();
      res.push(node.val);
      root = root.right;
    }
  }
  return res;
}
```

## 三、后序遍历(非递归版)

## 代码

```js
function postOrderTraversal(root) {
  let res = [];
  let stack = [];
  if (root == null) {
    return res;
  }
  stack.push(root);
  while (stack.length) {
    let node = stack.pop();
    res.unshift(node.val);
    if (root.left) {
      stack.push(node.left);
    }
    if (root.right) {
      stack.push(node.right);
    }
  }
  return res;
}
```

## 四、层次遍历

## 代码

```js
function printFromTopToBottom(root) {
  let res = [];
  let queue = [];
  if (root == null) {
    return res;
  }
  queue.push(root);
  while (queue.length) {
    let node = queue.shift();
    res.push(node.val);
    if (node.left != null) {
      queue.push(node.left);
    }
    if (node.right != null) {
      queue.push(node.right);
    }
  }
  return res;
}
```

## 五、二叉树的深度

## 思路：一旦没有找到节点就返回 0，每弹出一次递归函数就会加一，树有三层就会得到 3

## 代码

```js
function maxDepth(root) {
  if (!root) {
    return 0;
  }
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

## 六、对称二叉树

## 代码

```js
function isSymmetrical(pRoot) {
  return pRoot == null || judge(pRoot.left, pRoot.right);
}
function judge(node1, node2) {
  if (node1 == null && node2 == null) {
    return true;
  } else if (node1 == null || node2 == null) {
    return false;
  }
  if (node1.val !== node2.val) {
    return false;
  } else {
    return judge(node1.left, node2.right) && judge(node1.right, node2.left);
  }
}
```

## 七、平衡二叉树

## 代码

```js
function IsBalanced_Solution(pRoot) {
  return depth(pRoot) !== -1;
}
function depth(pRoot) {
  if (pRoot == null) {
    return 0;
  }
  let left = depth(pRoot.left);
  if (left === -1) {
    return -1;
  }
  let right = depth(pRoot.right);
  if (right === -1) {
    return -1;
  }
  return Math.abs(left - right) > 1 ? -1 : Math.max(left, right) + 1;
}
```

## 八、重建二叉树 (已知前序、中序遍历)

## 代码

```js
function reConstructorBinaryTree(pre, vin){
 let result = null;
 if(pre.length > 1){
  let root = pre[0];
  let index = vin.indexOf(root);
  let vinLeft = vin.slice(0, index);
  let vinRight = vin.slice(index + 1);
  pre.shift();
  let preLeft = pre.slice(0, vinLeft.length);
  let preRight = pre.slice(vinLeft.length);
  result = {
   val:root,
   left:reConstructorBinaryTree(preLeft, vinLeft),
   right:reConstructorBinaryTree(preRight, vinRight);
  }
 }else if(pre.length === 1){
  result = {
   val:pre[0],
   left:null,
   right:null
  }
 }
 return result
}
```

## 九、按层打印二叉树

## 思路：用队列存储二叉树每层的值，用数组存储每个队列的值

## 代码

```js
function Print(pRoot) {
  let res = [];
  let queue = [];
  if (!pRoot) {
    return res;
  }
  queue.push(pRoot);
  while (queue.length) {
    let len = queue.length;
    let temp = [];
    for (let i = 0; i < len; i++) {
      let node = queue.shift();
      temp.push(node.val);
      if (node.left) {
        queue.push(node.left);
      }
      if (node.right) {
        queue.push(node.right);
      }
    }
    res.push(temp);
  }
  return res;
}
```

## 十、之字形打印二叉树

## 思路：奇数行用栈存储，偶数行用队列存储

## 代码

```js
function Print(pRoot) {
  if (pRoot == null) {
    return [];
  }
  let queue = [],
    temp = [],
    res = [],
    level = 0,
    isEven = true,
    isBePrinted = 1;
  queue.push(pRoot);
  while (queue.length) {
    let node = queue.shift();
    //判断奇、偶行，奇数行
    if (isEven) {
      temp.push(node.val);
    } else {
      temp.unshift(node.val);
    }
    //行数加一
    if (node.left) {
      queue.push(node.left);
      level++;
    }
    if (node.right) {
      queue.push(node.right);
      level++;
    }
    //当前被操作行数已遍历完
    isBePrinted--;
    //处理行数、奇偶、temp置空
    if (isBePrinted === 0) {
      res.push(temp);
      temp = [];
      isBePrinted = level;
      level = 0;
      isEven = !isEven;
    }
  }
  return res;
}
```

## 十一、二叉搜索树的后序遍历序列

## 思路

> 1. 找出根节点，
> 2. 在不包括根节点的数组中遍历，找到第一个比根节点大的位置，该位置左边为左子树，右边为右子树
> 3. 遍历右子树，如果发现有小于根节点的值，直接返回 false
> 4. 递归以上步骤，分别判断左右子树是否为二叉搜索树

## 代码

```js
function VerifySquenceOfBST(arr) {
  if (arr == null || arr.length < 1) {
    return false;
  }
  return judge(arr, 0, arr.length - 1);
}
function judge(arr, left, right) {
  // 递归终止条件：只有一个节点
  if (left >= right) {
    return true;
  }
  // 找出根节点
  let node = arr[right];
  // 用来记录序列中第一个比根节点大节点的下标
  let index = right;
  for (let i = left; i < right - 1; i++) {
    // 找到根节点的右孩子
    if (arr[i] > node) {
      index = i;
      i++;
      // 如果右子树中有比根节点还小的树的话，显然是不成立的
      while (i <= right - 1) {
        if (arr[i] < node) {
          return false;
        }
        i++;
      }
    }
  }
  // 递归检查左右子树
  return judge(arr, left, index - 1) && judge(arr, index, right - 1);
}
```

## 十二、二叉搜索树第 K 个节点

## 思路：利用二叉搜索树的中序遍历是一个递增序列来解决，用数组存储遍历结果，返回第 k 个节点

## 代码

```js
function KthNode(pRoot, k) {
  if (pRoot == null || k < 1) {
    return null;
  }
  var arr = [];
  //中序遍历
  function getTree(root) {
    if (root.left) {
      getTree(root.left);
    }
    arr.push(root);
    if (root.right) {
      getTree(root.right);
    }
  }
  getTree(pRoot);
  return arr[k - 1];
}
```

## 十三、二叉树的最大宽度

## 思路

> 对节点进行编号，根节点编号是 0，左子树编号 = 根节点编号*2+1，右子树编号 = 根节点编号*2+2，
> 最大宽度 = 左子树编号 - 右子树编号 + 1

## 代码

```js
function maxWidthOfBinaryTree(root) {
  if (!root) {
    return 0;
  }
  let res = [],
    maxWidth = 1;
  recusion(root, 0, 0);
  return maxWidth;
  function recusion(root, level, num) {
    if (res[level]) {
      res[level].push(num);
    } else {
      res[level] = [num];
    }
    let tempArr = res[level];
    let tempWidth = tempArr[tempArr.length - 1] - tempArr[0] + 1;
    if (tempWidth > maxWidth) {
      maxWidth = tempWidth;
    }
    if (root.left) {
      recusion(root.left, level + 1, num * 2 + 1);
    }
    if (root.right) {
      recusion(root.right, level + 1, num * 2 + 2);
    }
  }
}
```

## 十四、二叉树的镜像

## 代码

```js
function Mirror(root) {
  //判断根节点
  if (root == null) {
    return;
  }
  //终止条件为当前节点为叶子节点
  if (root.left == null && root.right == null) {
    return root;
  }
  //交换左右子树
  let temp = root.left;
  root.left = root.right;
  root.right = temp;
  //递归左右子树镜像
  Mirror(root.left);
  Mirror(root.right);
}
```

## 十五、二叉树的下一个节点

## 思路

> 1. 二叉树为空，返回 null
> 2. 右子树存在，返回右子树的最左节点
> 3. 节点不是根节点。是父节点的左孩子，则返回父节点；否则向上去遍历父节点的父节点，重复之前的判断，返回结果。

## 代码

```js
function GetNext(pNode) {
  if (pNode == null) {
    return null;
  }
  if (pNode.right != null) {
    pNode = pNode.right;
    while (pNode.left != null) {
      pNode = pNode.left;
    }
    return pNode;
  }
  while (pNode.next != null) {
    let pRoot = pNode.next;
    if (pRoot.left === pNode) {
      return pRoot;
    }
    pNode = pNode.next;
  }
  return null;
}
```
