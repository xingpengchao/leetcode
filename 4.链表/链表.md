## 三、合并两个有序链表

## 代码

```
const mergeTwoLists = function(A, B){
 if(A == null){
  return B;
 }
 if(B == null){
  return A;
 }
 if(A.val < B.val){
  A.next = mergeTwoLists(A.next, B);
  return A;
 }else{
  B.next = mergeTwoLists(A, B.next);
  return B;
 }
}
```

## 四、链表中倒数第 K 个节点

## 解法一：队列

## 思路：拿一个队列保存

```
function findKthToTail(head, k){
 let result = [];
 while(head){
  result.unshift(head);
  head = head.next;
 }
 return result[k-1];
}

```

## 解法二：双指针

## 思路： 快指针先走 k-1 步，之后快慢指针同步走，当快指针走到最后一个结点的时候，慢指针也走到了倒数第 k 个结点

## 代码

```
function findKthToTail(head, k){
 if(!head || !k || k<=0){
  return null;
 }
 let low = head;
 let fast = head;
 for(let i=0; i<k-1; i++){
  if(fast.next){
   fast = fast.next;
  }else{
   return null;
  }
 }
 while(fast.next){
  fast = fast.next;
  low = low.next;
 }
 return low;
}
```

## 五、两个链表的第一个公共节点

## 思路：用两个指针扫描两个链表，最终两个指针到达 null 或者到达公共节点

## 代码

```
function FindFirstCommonNode(pHead1, pHead2){
    let p1 = pHead1;
    let p2 = pHead2;
    while(p1 !== p2){
        p1 = p1 == null ? pHead2 : p1.next;
        p2 = p2 == null ? pHead1 : p2.next;
    }
    return p1;
}
```

## 六、判断链表是否有环 (百度手撕)

## 解法一：ES6 的 Set

> ## 时间复杂度：O(n) 空间复杂度：O(n)

## 代码

```
function hasCycle(head){
    let st = new Set();
    while(head){
        if(st.has(head)){
            return true
        }
        st.add(head);
        head = head.next;
    }
    return false
}
```

## 解法二：双指针

## 思路：快慢指针起初都在头节点，慢指针一步走，快指针两步走，判断快慢指针是否相遇，相遇则链表有环，否则无环

> ## 时间复杂度：O(n) 空间复杂度：O(1)

## 代码

```
function hasCycle(head){
    if(head == null || head.next == null){
        return false
    }
    let fast = head;
    let low = head;
    while(fast != null && fast.next != null){
        fast = fast.next.next;
        low = low.next;
        if(fast === low){
            return true
        }
    }
    return false
}
```

## 七、两数相加(leetcode 2)

## 思路：链表转数组 => 数组转数字 => 求和 => 数组转链表

> ## 时间复杂度：O(Max(m,n)) 空间复杂度：O(Max(m,n))

## 代码

```
// 链表节点
function ListNode(val){
    this.val = val;
    this.next = null;
}
function addTowNumbers(l1,l2){
    // 链表转数组
    let arr1 = [],arr2 = [];
    while(l1){
        arr1.push(l1.val);
        l1 = l1.next;
    }
    while(l2){
        arr2.push(l2.val);
        l2 = l2.next;
    }
    // 数组转数字并求和
    const num1 = BigInt(arr1.reverse().join(''));
    const num2 = BigInt(arr2.reverse().join(''));
    const res = String(num1+num2).split('');
    // 数组转链表
    let result = null;
    for(let i=0; i<res.length; i++){
        let current = new ListNode(res[i]);
        current.next = result;
        result = current;
    }
    return result;
}
```
