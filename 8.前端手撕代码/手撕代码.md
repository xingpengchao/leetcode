### Promise A+规范

```js
class Promise {
  constructor(executor) {
    this.state = "pending";
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    let resolve = (value) => {
      if (this.state === "pending") {
        this.state = "fulfilled";
        this.value = value;
        this.onResolvedCallbacks.forEach((fn) => fn());
      }
    };
    let reject = (reason) => {
      if (this.state === "pending") {
        this.state = "rejected";
        this.reason = reason;
        this.onRejectedCallbacks.forEach((fn) => fn());
      }
    };
    try {
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }
  then(onFulfilled, onRejected) {
    // onFulfilled如果不是函数，就忽略onFulfilled，直接返回value
    onFulfilled =
      typeof onFulfilled === "function" ? onFulfilled : (value) => value;
    // onRejected如果不是函数，就忽略onRejected，直接扔出错误
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (err) => {
            throw err;
          };
    let promise2 = new Promise((resolve, reject) => {
      if (this.state === "fulfilled") {
        // 异步
        setTimeout(() => {
          try {
            let x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      }
      if (this.state === "rejected") {
        // 异步
        setTimeout(() => {
          // 如果报错
          try {
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        }, 0);
      }
      if (this.state === "pending") {
        this.onResolvedCallbacks.push(() => {
          // 异步
          setTimeout(() => {
            try {
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0);
        });
        this.onRejectedCallbacks.push(() => {
          // 异步
          setTimeout(() => {
            try {
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          }, 0);
        });
      }
    });
    // 返回promise，完成链式
    return promise2;
  }
}
```

## 十二、手撕 Promise.all

```js
function promiseAll(promises) {
  return new Promise(function (resolve, reject) {
    if (!Array.isArray(promises)) {
      return reject(new Error("Promises must be an array"));
    }
    let resolvedCount = 0;
    let promiseNum = promises.length;
    let resloveValue = [];
    for (let i = 0; i < promiseNum; i++) {
      Promise.resolve(promises[i]).then(
        (value) => {
          resloveValue[i] = value;
          resolvedCount++;
          if (resolvedCount === promiseNum) {
            return resloveValue;
          }
        },
        (err) => {
          return reject(err);
        }
      );
    }
  });
}
```

## 十三、Promise 封装异步上传图片

```js
function loadImageAsync(url) {
  return new Promise(function (resolve, reject) {
    var image = new Image();
    image.onload = function () {
      resolve(image);
    };
    image.onerror = function () {
      reject(new Error("Could not load image at" + url));
    };
    image.src = url;
  });
}
```

## 十四、红黄路灯(字节跳动经典面试题)

## 题目：红灯 3 秒亮一次，绿灯 2 秒亮一次，黄灯 1 秒亮一次；如何让三个灯不断交替重复亮灯？

## 思路：Promise + 递归

```js
function red() {
  console.log("red");
}
function green() {
  console.log("green");
}
function yellow() {
  console.log("yellow");
}

const light = function (timmer, cb) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      cb();
      resolve();
    }, timmer);
  });
};

const step = function () {
  Promise.resolve()
    .then(() => {
      light(3000, red);
    })
    .then(() => {
      light(2000, green);
    })
    .then(() => {
      light(1000, yellow);
    })
    .then(() => {
      step();
    });
};

step();
```

## 十五、spawn 函数(Async 函数实现原理)

## 说明：spwan 函数--自动执行器，需先了解 Generator 函数，Async/await 是 Generator 函数的语法糖

```js
function spawn(genF) {
  return new Promise((resolve, reject) => {
    var gen = genF();
    function step(nextF) {
      try {
        var next = nextF();
      } catch (e) {
        return reject(e);
      }
      if (next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(
        (v) => {
          step(() => gen.next(v));
        },
        (e) => {
          step(() => gen.throw(e));
        }
      );
    }
    step(() => {
      gen.next(undefined);
    });
  });
}
```

## 十六、thunk 函数(Generator 函数实现自动流程管理原理)

## 说明

> Thunk 函数是用来解决 JS 中传名调用的一种实现方式
> Thunk 函数是一个单参数函数，只接受回调函数作为参数
> Thunk 函数用于 Generator 函数的自动流程管理

(ES5)

```js
var Thunk = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments);
    return function (callback) {
      args.push(callback);
      return fn.apply(this, args);
    };
  };
};
```

(ES6)

```js
const Thunk=function(fn){
  return fucntion(...args){
    return function(callback){
      return fn.call(this, ...args, callback);
    }
  }
}
```

## 十七、防抖

```js
const debounce = (func, wait) => {
  let timer;
  return function (...args) {
    let _self = this;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      func.apply(_self, args);
    }, wait);
  };
};
```

## 十八、节流

```js
const throttle = (func, wait) => {
  let previous = 0;
  return function (...args) {
    let now = Date.now();
    let _self = this;
    if (now - previous > wait) {
      func.apply(_self, args);
      previous = now;
    }
  };
};
```
